# 数、位、浮点数

```javascript
var buffer = new ArrayBuffer(8);
var view = new Float32Array(buffer);
console.log(Math.pow(2, 33))
// 如果是Uint32Array,最大值为Math.pow(2, 32) - 1
// 如果是Int32Array,最大值为Math.pow(2, 31) - 1
// 如果是Float32Array,表示范围更大，但是不能精确，
// 比如Math.pow(2, 32)和Math.pow(2,32)-1,
// 如果使用浮点来存储，则值是一样的。
// float32; 1位符号位，8位指数位，23位小数位
// IEEE754规定float的有效值为“小数部分 + 1”
// 小数部分全为0，表示的实际有效数字为1.0
// 小数部分全为1，表示的实际有效数字约为2
// 0.11111111111111111111 对应 1.11111111111111111111
// 二进制1.11111111111111111111 约等于10进制的 2

view[0] = Math.pow(2,33);
view[1] = 2222222;
view[2] = 3333333;
view[3] = 2222222;
console.log(view[3])
```

所以，在js中常常遇到`0.1+0.2=0.3000000000004`的问题。是因为要计算0.1+0.2,计算机会先把小数转换成2进制，然后相加。但是有一些浮点数在转换成2进制的时候会出现无限循环。比如十进制的0.1转换为2进制会是如下结果：

```javascript
0.1 => 0.0001 1001 1001 1001…（无限循环）

0.2 => 0.0011 0011 0011 0011…（无限循环）
```

然后对位相加重新转成10进制的时候就会出现多的位。

1. 什么是双精度浮点数？为什么要叫做双精度？
  
  使用 64 位（8字节） 来存储一个浮点数。 它可以表示十进制的15或16位有效数字，其可以表示的数字的绝对值范围大约是：-1.7E-308～1.7E+308。

  单精度浮点数在机内占4个字节
  双精度浮点数在机内占8个字节

  单精度浮点数有效数字8位
  双精度浮点数有效数字16位

2.js能表示的最大数是多少？最大的安全整数是多少？

MAX_VALUE: Math.pow(2, 1024) - Math.pow(2,971)
Number.MAX_SAFE_INTEGER: Math.pow(2, 53) - 1

3.js toPrecision vs toFixed有什么区别问题?

数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。

toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。

toFixed 是小数点后指定位数取整，从小数点开始数起。

```javascript
var a = 0.000001555;
a.toPrecision(1); // 0.000002
a.toFixed(1); // 0.0
a.toFixed(6); // 0.000002
a.toFixed(12); // 00.000001555500

```

两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。

如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。

原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！

4.如何解决浮点误差？

*数据展示类*当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示

```js
parseFloat(1.4000000000000001.toPrecision(12)) === 1.4  // True
```

封装成方法就是：

```js
function strip(num, precision = 12) {
  return +parseFloat(num.toPrecision(precision));
}
```

为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。

*数据运算类*对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例：

```js
/**
 * 精确加法
 */
function add(num1, num2) {
  const num1Digits = (num1.toString().split('.')[1] || '').length;
  const num2Digits = (num2.toString().split('.')[1] || '').length;
  const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits));
  return (num1 * baseNum + num2 * baseNum) / baseNum;
}
```

以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。

解决办法，使用[number-precision](https://github.com/nefe/number-precision),Math.js、BigDecimal.js等库。

5.十进制小数如何转2进制？

十进制的小数转换为二进制，主要是小数部分乘以2，取整数部分依次从左往右放在小数点后，直至小数点后为0。
小数0.1,转换成2进制
0.1 * 2 = 0.2 => 0
0.2 * 2 = 0.4 => 0
0.4 * 2 = 0.8 => 0
0.8 * 2 = 1.6 => 1
0.6 * 2 = 1.2 => 1
0.2 * 2 = 0.4 => 0
所以小数0.1的二进制表示是0.00011001100110011...

等同于 1.100110011001 * (2^-4); 小数点向右移动一位表示乘以2，一共移动了4位。所以`0.00011001001001... * (2 ^ 4) = 1.10011001...`,那么`1.10011001...`除以(2^4)等于`1.10011001... * (2^-4)`
