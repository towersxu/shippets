# SOLID

## 单一职责

> 一个类或者模块只负责完成一个职责 (A class or module should have a single reponsibility)

### 如何判断类的职责是否单一

1. 代码行数过多的时候。
2. 比较难起合适名字的时候，说明其职责不够清晰。
3. 类的依赖过多的时候，说明可能不符合高内聚、低耦合的思想。
4. 类中大量的方法都是操作个别属性的时候，可能这个属性和这些方法就需要拆分出来。

### 类的职责是不是越单一越好

不是，不管是设计模式还是设计原则，最终的目的还是提高代码的可读性。
单一职责避免设计大而全的类，避免将不相关的功能耦合在一起，来提高内聚性。
但是如果拆分的太细，反而会降低内聚性。

## 开闭原则

> 软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。

开闭原则的初衷，不破坏原有代码的运行和原有的单元测试。
开闭原则主要讲的就是扩展性问题，是非常重要的判断代码扩展性的标准。

### 举一个实际例子说明开闭原则

假设有一个方法，是对老师、学生、管理员来进行评分的。老师和学生有不同的评分规则。
如果我们直接在这个方法中使用不同的if来进行判断。之后再需要把学生分成不同年级的学生，
或者再加一个角色，就需要再到这个方法内部来进行修改了。这其实就违反了开闭原则。

解决办法是，把这个方法重构一下，接收参数直接是一个代码计算评分的对象。
这个对象的类可以继承一个统一的抽象类，这个抽象类就是带有评分方法，
每个类可以自己实现这个评分方法。这样之后就算有新加角色，
也只需要再新建一个类去实现这个抽象类即可。这样就不会影响到其它代码。

### 工作中一定要所有的地方都遵守开闭原则吗

不需要，不要为了一些遥远的，不一定发生的需求去提前买单，做过度设计。
最合适的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动、实现成本不高的情况。
可以事先作扩展性设计。对于比较复杂的扩展点，可以等有需求驱动的时候再通过代码重构来实现。

## 里式替换原则

> 子类对象能够替换程序中父类对象出现在任何地方，并且保证原来程序的逻辑行为不变及正确性不被破坏。

里式替换原则最核心的理解是“按照协议来设计”，子类在实现的时候不能改变父类的约定。
即输入、输出、异常的约定。可以理解为子类完美继承父类的设计初衷，并做了增强。

## 接口隔离原则

### 如何理解“接口隔离原则”

接口隔离原则提供了一种判断接口的职责是否单一的标准。如果调用者只使用了接口的部分功能，那么接口的职责就不单一了。

## 依赖反转原则

依赖反转原则也叫作依赖倒置原则。这条原则跟控制反转有点类似，主要用来指导框架层面的设计。高层模块不依赖低层模块，它们共同依赖同一个抽象。抽象不要依赖具体实现细节，具体实现细节依赖抽象。



