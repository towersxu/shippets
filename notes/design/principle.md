# 设计原则

## 如何理解基于接口而非实现编程

这条原则可以将接口与实现相分离，封装不稳定的实现，暴露稳定的接口。
上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发送变化的时候，
上游系统的代码基本不需要做改动，以此来降低耦合性，提高扩展性。

软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。
越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。

在编写代码的时候要遵从“基于接口而非实现编程”需要做到的点：

1. 函数的命名不能暴露任何实现细节
2. 封装具体的实现细节
3. 为实现类定义抽象的接口

## 如何理解组合由于继承

继承的最大问题在于：继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

相对于接口+组合+委托增加的复杂度，代码统一成接口+组合+委托带来的好处更多，利于阅读和交流，毕竟读代码的次数大于写的次数，读一种类型的代码的难度远低于读两种类型。

## 如何理解KISS原则

> `Keep It Simple and Stupid`

KISS原则是保持代码尽可能的简单、易懂。不过分优化性能和炫技。
不要重复造轮子，要善于使用已经有的工具类库。
经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。

## 什么是YAGNI原则

YAGNI 原则的英文全称是：You Ain’t Gonna Need It。直译就是：你不会需要它。
这条原则的核心思想就是：不要做过度设计。

## 如何理解DRY原则

> `Don‘t repeat yourself`

实现逻辑重复，但功能语义不重复的代码，并不违反 DRY 原则。
实现逻辑不重复，但功能语义重复的代码，也算是违反 DRY 原则。

## 什么是迪米特法则（LOD）

> Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.

每个模块（unit）只应该了解那些与它关系密切的模块（units: only units “closely” related to the current unit）的有限知识（knowledge）。或者说，每个模块只和自己的朋友“说话”（talk），不和陌生人“说话”（talk）。

- 那到底什么是“高内聚”呢？

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。

- 什么是“松耦合”

所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。
