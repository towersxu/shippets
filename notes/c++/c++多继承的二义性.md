# c++多继承的二义性

c++是可以多继承的，只要支持多继承，就离不开解决多继承导致的二义性。

```cpp
class A{
  public:
    void f();
}

class B{
  public:
    void f();
    void g();
}

class C:public A,public B{
  public:
    void g();
    void h();
};
```

如果声明：C c1，则c1.f();具有二义性，而c1.g();无二义性（同名覆盖)。

## 解决办法

1. 类名限定

调用时指名调用的是哪个类的函数，如

```cpp
c1.A::f();
c1.B::f();
```

2.同名覆盖

在C中声明一个同名函数，该函数根据需要内部调用A的f或者是B的f。如

```cpp
class C:public A,public B{
  public:
    void g();
    void h();
    void f(){
        A::f();
    }
};
```

3.虚基类（用于有共同基类的场合)

虚基类主要用来解决多继承时，可能对同一基类继承继承多次从而产生的二义性。为最远的派生类提供唯一的基类成员，而不重复产生多次拷贝。注意：需要在第一次继承时就要将共同的基类设计为虚基类。虚基类及其派生类构造函数建立对象时所指定的类称为最（远）派生类。

- 虚基类的成员是由派生类的构造函数通过调用虚基类的构造函数进行初始化的。

- 在整个继承结构中，直接或间接继承虚基类的所有派生类，都必须在构造函数的成员初始化表中给出对虚基类的构造函数的调用。如果未列出，则表示调用该虚基类的缺省构造函数。

- 在建立对象时，只有最派生类的构造函数调用虚基类的构造函数，该派生类的其他基类对虚基类的构造函数的调用被忽略。

Java/js不支持多继承。
