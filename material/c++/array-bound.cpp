#include <stdio.h>

/**
 * 数组越界在 C 语言中是一种未决行为,
 * 并没有规定数组访问越界时编译器应该如何处理。
 * 因为,访问数组的本质就是访问一段连续内存,
 * 只要数组通过偏移计算得到的内存地址是可用的,
 * 那么程序就可能不会报任何错误。
 * 
 * 函数体内的局部变量存在栈上,且是连续压栈。
 * 在Linux进程的内存布局中,栈区在高地址空 间,
 * 从高向低增长。
 * 变量i和arr在相邻地址,且i比arr的地址大,
 * 所以arr越界正好访问到i。
 * 当 然,前提是i和arr元素同类型,
 * 否则那段代码仍是未决行为。
 * 
 * 例子中死循环的问题跟编译器分配内存和字节对齐有关
 * 数组3个元素 加上一个变量a 。
 * 4个整数刚好能满足8字节对齐
 * 所以i的地址恰好跟着a2后面导致死循环。
 * 如果数组本身有4个元 素 则这里不会出现死循环。
 * 因为编译器64位操作系统下 默认会进行8字节对齐
 * 变量i的地址就不紧跟着数组后面了。
 * 
 * 关于数组越界访问导致死循环的问题,
 * 我也动手实践了一下,发现结果和编译器的实现有关,
 * gcc有一个编译选项(-fno-stack-protector)
 * 用于关闭堆栈保护功能。
 * 默认情况下启动 了堆栈保护,
 * 不管i声明在前还是在后,
 * i都会在数组之后压栈,只会循环4次;
 * 如果关闭堆栈保护功能,则会出现死循环。
 * 请参考:https://www.ibm.com/developerworks/cn/linux/l-cn-gccstack/index.html
 */

int main(int argc, char *argv[])
{
  int i = 0;
  int arr[3] = {0};
  for (; i <= 3; i++)
  {
    arr[i] = 0;
    printf("hello world\n");
  }
}