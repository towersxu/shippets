# ES6中的正则面试点整理

## Q1: 正则表达式能匹配四字节字符吗

ES5是不行的，ES6新增了一个`u`修饰符可以识别四字节字符。
另外，对应ES6新增的大括号表示unicode字符，必须使用`u`修饰符才能匹配。

## Q2: 正则表达式中`y`修饰符有什么用

y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。

y修饰符号隐含了头部匹配的标志^。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。

单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。

y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。

## Q3: js如何获取一个正则表达式的修饰符

```js
/abc/ig.source // abc
/abc/ig.flags // gi
```

## Q4: 正则表达式`s`修饰符有什么用

正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。

所谓行终止符，就是该字符表示一行的终结。以下四个字符属于“行终止符”。

- U+000A 换行符（\n）
- U+000D 回车符（\r）
- U+2028 行分隔符（line separator）
- U+2029 段分隔符（paragraph separator）

ES2018 引入s修饰符，使得.可以匹配任意单个字符。这被称为dotAll模式，即点（dot）代表一切字符。

## Q5: 正则表达式的先行断言和后行断言是什么

匹配%前面的数字`/\d+(?=%)/`可以使用先行断言

先行否定断言，匹配不在%前面的数字`/\d+(?!%)`

在ES2018引入了`后行断言`

匹配美元符号后面的数字`/(?<=\$)\d+/`

匹配不在美元符号后面的数字`/(?<!\$)\d+/`

注意：后行断言的执行顺序是从右向左

## Q6: 正则表达式属性类是什么

ES2018 引入了一种新的类的写法\p{...}和\P{...}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。

```js
// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu
// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true
```

## Q7: 什么是具名组匹配

ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。

```js
const RE_DATE = /(?<year>\d{4})-(?<month>\d{2})-(?<day>\d{2})/;
const {groups: {year='2000', month='01', day='01'} = {}} = RE_DATE.exec('1991-03-03') || {};
console.log(year, month, day) // 2000-
```

具名匹配还可以在正则里面使用`\k<组名>`引用

```js
let str2 = '张三的爸爸叫张二，他爷爷叫张一'
const RE_1 = /^(?<firstName>.{1})三的爸爸叫\k<firstName>二，他爷爷叫\k<firstName>一/
console.log(RE_1.test(str2))
```

## Q8: 字符串的matchAll返回的是什么

目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。
