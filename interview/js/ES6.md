# ES6基础问题

> Q1: 在js最开始使用let定义一个变量，这个变量会不会绑定到window上？

这里和var不同，let定义的"全局变量"不会绑定到window上。这是因为ES6规范中将`全局环境记录`定义分为了两部分组成。
一部分是全局对象，另一部分是全局声明环境。之前的`var`、`function`直接绑定到全局对象上，可以直接在全局中用this访问。
`let`、`const`、`class`则是在全局声明环境中，不会被绑定到全局对象上。

ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

现在有一个提案，在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。

垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。

所以，在浏览器上这段代码会打印`undefined`

```js
let x = 10;
function fn () {
  console.log(this.x) // undefined
}
fn()
```

如果是var声明的x，则会打印undefined

> Q2: 什么是块级作用域？

ES6之前，只有全局作用域和函数作用域。ES6新增了一种块级作用域。块级作用域是指`if`、`for`、`{}`等语句块内部单独作用一个块级作用域，在块级作用域里面，不会影响val的声明提升，但是会使let形成`暂时性死区`。

内层作用域可以定义外层作用域的同名变量。

```js
let x1 = 111;
if (x1 > 100) {
  let x1 = 200;
  console.log(x1) // 200
}
```

所以如果在for循环里面在声明i，也是不会影响

```js
let arr22 = [1,2,3,4,5]
for (let i = 0; i < arr22.length; i++) {
  let i = 20;
  console.log(i); // 打印5个20
}
```

ES6明确允许在块级作用域之中声明函数。
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

在ES5中，函数会被提升到顶部，相当于外面也可以引用。

ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

- 允许在块级作用域内声明函数。
- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

> Q3: 什么是暂时性死区？

只要块级作用域内存在let或const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。这块区域也会变成块级作用域，如果在区域内let、const声明之前使用这些变量，就会报错。

```js
function bar(x = y, y = 2) {
  return [x, y];
}
bar(); // 报错

function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```

调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。



