# ES6基础面试题

## Q1: 在js最开始使用let定义一个变量，这个变量会不会绑定到window上？

这里和var不同，let定义的"全局变量"不会绑定到window上。这是因为ES6规范中将`全局环境记录`定义分为了两部分组成。
一部分是全局对象，另一部分是全局声明环境。之前的`var`、`function`直接绑定到全局对象上，可以直接在全局中用this访问。
`let`、`const`、`class`则是在全局声明环境中，不会被绑定到全局对象上。

ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。

现在有一个提案，在语言标准的层面，引入globalThis作为顶层对象。也就是说，任何环境下，globalThis都是存在的，都可以从它拿到顶层对象，指向全局环境下的this。

垫片库global-this模拟了这个提案，可以在所有环境拿到globalThis。

所以，在浏览器上这段代码会打印`undefined`

```js
let x = 10;
function fn () {
  console.log(this.x) // undefined
}
fn()
```

如果是var声明的x，则会打印10

## Q2: 什么是块级作用域？

ES6之前，只有全局作用域和函数作用域。ES6新增了一种块级作用域。块级作用域是指`if`、`for`、`{}`等语句块内部单独作用一个块级作用域，在块级作用域里面，不会影响var的声明提升，但是会使let形成`暂时性死区`。

内层作用域可以定义外层作用域的同名变量。

```js
let x1 = 111;
if (x1 > 100) {
  let x1 = 200;
  console.log(x1) // 200
}
```

所以如果在for循环里面在声明i，也是不会影响.

```js
let arr22 = [1,2,3,4,5]
for (let i = 0; i < arr22.length; i++) {
  let i = 20;
  console.log(i); // 打印5个20
}
```

ES6明确允许在块级作用域之中声明函数。
ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。

在ES5中，函数会被提升到顶部，相当于外面也可以引用。

ES6 在附录 B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。

- 允许在块级作用域内声明函数。
- 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。
- 同时，函数声明还会提升到所在的块级作用域的头部。

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

严格模式下，函数只能声明在当前作用域的顶层。

```js
{
  let a = 'a';
  let f = function () {
    return a;
  }
}
```

注意：块级作用域必须要有大括号，如果没有大括号，Js引擎就认为不存在块级作用域。

```js
if (true) let a = 1; // 报错
```

## Q3: 什么是暂时性死区？

只要块级作用域内存在let或const命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。这块区域也会变成块级作用域，如果在区域内let、const声明之前使用这些变量，就会报错。

```js
function bar(x = y, y = 2) {
  return [x, y];
}
bar(); // 报错

function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
```

调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于“死区”。如果y的默认值是x，就不会报错，因为此时x已经声明了。

## Q4: 如果想要声明一个对象为常量，应该怎么做？

```js
const OBJ = Object.freeze({})
```

当一个常量指向被冻结的对象，向这个对象添加属性将不起作用。如果是严格模式，将会报错。

注意：如果只是直接冻结，其实对于这个对象的属性如果还是对象，那么这个对象没有被冻结。
所以如果想要完全冻结，需要变量所有的属性并递归冻结。

```js
let freeze = (obj) => {
  Object.free(obj);
  Object.keys(obj).forEach((key) => {
    if (typeof obj[key] === 'object') {
      freeze(obj[key])
    }
  })
}
```

## Q5: js目前有那些声明变量的方法

目前有6种: `var`、`function`、`let`、`const`、`import`、`class`

## 为什么装饰器不能用于函数

装饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。

## 装饰器常见的用途

core-decorators.js是一个第三方模块，提供了几个常见的装饰器，通过它可以更好地理解装饰器。

- `@autobind`装饰器使得方法中的this对象，绑定原始对象。
- `@readonly`装饰器使得属性或方法不可写。
- `@override`检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。
- `@deprecate`: deprecate或deprecated装饰器在控制台显示一条警告，表示该方法将废除。

在装饰器的基础上，可以实现Mixin模式。
