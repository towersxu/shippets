# 解构与扩展运算符

ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构(Destructuring)。

ES6 引入 rest 参数（形式为...变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。

> Q1： 如何给请求返回的data设置默认值

```js
ajax.then(({ data = {}}) => {})
```

> Q2: 如果希望把上面的data改成另一个名字呢？因为data在前面已经有声明的了。

使用冒号

```js
ajax.then(function({ data: data1 = 22 }) {
  console.log(data1)
})
```

如果上面的代码可能出现什么也不返回，会不会报错

```js
ajax.then(function({ data: data1 = 22 } = {}) {
  console.log(data1) // 22
})
```

会报错，所以一般会使用=赋值默认空对象

> Q3: 下面代码打印内容是

```js
let x = 99;
function foo(p = x + 1) {
  console.log(p);
}
foo()
x = 200;
foo()
```

先打印100，后打印201。因为是默认参数是惰性求值，每次调用都会重新计算。并不是函数被声明的时候就计算好了。

> Q4: 如何将一个对象中除了某些属性之外，剩下的属性作为一个新对象。

```js
let obj = {a: 1, b: 2, c: 3, d: 4}

let {a, ...obj2} = obj

console.log(obj2)
```

> Q5: 解构是否能用到Set上面？

可以，Set的顺序是按照插入的顺序排列的。所以解构的顺序也可以按照插入的顺序来。只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。

> Q6: 使用解构获取下面代码中的p,hello,y

```js
let obj = {
  p: [
    'Hello',
    { y: null }
  ]
};

let { p, p: [x, { y = 10 }] } = obj
```

因为p是模式，不是变量，所以需要再多写一个p。另外，这里y得到的内容是null不是默认值10。默认值生效的条件是，对象的属性值严格等于undefined。

> Q7: 下面的代码执行结果是？

```js
let x;
{x} = {x: 1};
```

上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。

```js
// 正确的写法
let x;
({x} = {x: 1});
```

> Q8: 字符串是否支持解构实现

支持, 比如可以下面这样写

```js
let string = 'hello world';
let [, ...res] = string
```

注意，不论是字符串还是数组都不能使用rest获取中间的, 因为rest只能是最后一个元素`let [a, ...res, b]`会报错。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。
由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。

> Q9: 解构那些情况可以用括号，那些情况不能用括号

不允许使用括号：

1.变量声明语句

2.函数参数

3.赋值语句的模式

```js
// 报错
let [(a)] = [1];
function f([(z)]) { return z; }
([a]) = [5];
```

可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。
因为首先它们都是赋值语句，而不是声明语句

```js
[(b)] = [3]; // 正确
```

> Q10： 如何使用解构交换两个变量的值

```js
let a = 1
let b = 2
[b, a] = [a, b]
```

> Q11: 如何快速遍历map获取其value

```js
for (let [, val] of map) {
  console.log(val)
}
```

注意map遍历返回的是key，value组成的数组

