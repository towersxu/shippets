# function

## 如何利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误

```js
function throwIfMissing() {
  throw new Error('Missing parameter');
}
function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}
```

## 函数参数有默认值了，为什么就不能把函数设置为严格模式

从 ES5 开始，函数内部可以设定为严格模式。
ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。

这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。

## 如果将一个匿名函数赋值给一个变量，那么这个变量的name属性是什么

在ES5中，这个变量的name是空字符串，在ES6中会返回实际的名称，也就是这个变量名

## 箭头函数能用arguments吗

不能、该对象在函数体内不存在。如果要用，可以用rest参数代替。

不可以使用yield命令，因此箭头函数不能用作 Generator 函数。

也不能使用new

由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。

除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。

## 什么是尾调用、什么是尾递归

尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。

尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。这就叫做尾调用优化。

注意，目前只有 Safari 浏览器支持尾调用优化，Chrome 和 Firefox 都不支持。

递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。

## 什么是柯里化

柯里化在js中的写法是一个函数，返回另一个函数。由于闭包的关系，返回的这个函数是可以获取外部函数的参数的。

```js
var curry = function (a) {
  return function (b) {
    return a + b
  }
}
var addThree = curry(3);
addThree(4);
```

优点： 用已有的函数组合出新的函数, 而柯里化每消费一个参数, 都会返回一个新的部分配置的函数, 这为函数组合提供了更灵活的手段, 并且使得接口更为流畅.

## 函数参数的尾逗号

ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。

## [...5] 如何扩展成 [0,1,2,3,4,5]

数组展开操作符只能作用于部署了遍历器对象的数据结构，如果非要实现这种操作，可以使用下面的实现：

```js
Number.prototype[Symbol.iterator] = function*() {
  let i = 0;
  let num = this.valueOf();
  while (i <= num) {
    yield i++;
  }
}
```
