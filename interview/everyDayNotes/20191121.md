# 2019年11月21日

## final

*声明变量为final*，等同于JavaScript的const, 对于基本类型，final使数值不变。对于引用类型，final使引用不变，也就不能引用其它对象，但是被引用的对象本身是可以修改的。

*声明方法为final*, 表示改方法不能被子类重写。(PS, 和private的不一样的地方是，子类可以自己实现一个和父类的被private修饰的方法)

private 方法隐式地被指定为 final，如果在子类中定义的方法和基类中的一个 private 方法签名相同，此时子类的方法不是重写基类方法，而是在子类中定义了一个新的方法。

*声明类为final*, 表示声明的类不允许集成。

## static

`静态变量`：又称为类变量，也就是说这个变量属于类的，类所有的实例都共享静态变量，可以直接通过类名来访问它。静态变量在内存中只存在一份。

`静态方法`：在类加载的时候就存在了，它不依赖于任何实例。所以静态方法必须有实现，也就是说它不能是抽象方法。只能访问所属类的静态字段和静态方法，方法中不能有 this 和 super 关键字。

`静态语句块`: 静态语句块在类初始化时运行一次。

`静态内部类`: 非静态内部类依赖于外部类的实例，而静态内部类不需要。

## 反射

反射是在运行的时候，动态的加载类、调用方法和熟悉的机制。

Java中的反射是使用`Class`对象，在类第一次使用的时候，使用`Class.forName("demo.java.reflect.Phone")`获取需要反射的类的class对象。class对象有三个方法,返回`java.lang.reflect`里面对应的类型。

- `Constructor`: clz.getConstructor()
- `Method`: clz.getMethod("setPrice", int.class)
- `Field`: clz.getFields()

js的反射也是一样，比如在运行的时候，给对象添加随机键名的方法，然后就不能使用`.`运算符调用这个方法，因为方法的名称在运行的时候才确定的。所以这里也可以用反射。

*反射的缺点*:

- **性能开销** :反射涉及了动态类型的解析，所以 JVM 无法对这些代码进行优化。因此，反射操作的效率要比那些非反射操作低得多。我们应该避免在经常被执行的代码或对性能要求很高的程序中使用反射。
- **安全限制** :使用反射技术要求程序必须在一个没有安全限制的环境中运行。如果一个程序必须在有安全限制的环境中运行，如 Applet，那么这就是个问题了。
- **内部暴露** ：由于反射允许代码执行一些在正常情况下不被允许的操作（比如访问私有的属性和方法），所以使用反射可能会导致意料之外的副作用，这可能导致代码功能失调并破坏可移植性。反射代码破坏了抽象性，因此当平台发生改变的时候，代码的行为就有可能也随着变化。

```js
var name = 'fn_' + Math.ceil(Math.random() * 1000)
Reflect.set(window, name, function () {

})
// 虽然也可以window[name] = function () {}
// 但是使用typescript的时候不支持。

```

## 异常

- Exception
  - IOException
    - EOFException
    - FileNotFoundException
  - RuntimeException
    - MissingResourceException
    - ClassNotFoundException
- Error
  - VirtualMachineError
  - AWTError

## 泛型

泛型只有在编译阶段有效，在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。

使用泛型的主要目的是确保类型安全，可以消除强制类型转换。

*泛型类*：通过泛型类可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。

*泛型接口*：泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中。

*泛型通配符*：

Joshua Bloch 在 《Effective Java》一书中建议使用 List 来代替 Array，因为 List 可以提供编译期的类型安全保证，而 Array 却不能。

你可以把任何带参数的类型传递给原始类型 List，但却不能把 List< String> 传递给接受 List< Object> 的方法，因为泛型的不可变性，会产生编译错误。
