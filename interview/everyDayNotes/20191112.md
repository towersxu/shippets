# 2019年11月12日

浏览器检测css属性

```js
result = CSS.supports('filter', 'blur(5px)'); // true

// 当浏览器不支持某个CSS属性的时候，就算你强制设置，获取的计算值也不会是你设置的属性值
document.head.style.filter = 'blur(5px)';
result = window.getComputedStyle(document.head).filter == 'blur(5px)';

```

CSS Object Model

*分治算法*一般是通过递归来实现的，在每一层递归中，都会涉及到将原问题分解为一些列子问题，如果子问题足够小，则直接求值。最后将子问题的结果合并。

*分治算法的条件*是原问题分解成的子问题具有相同模式，子问题能独立求解，相互之间也没有相关性。

如何计算出一组数中逆序对的个数？

在理想的排序过程，每次两个数交换就是一个逆序对。在我们常见的排序中，快速排序、插入排序、归并排序他们是否有额外的交换呢？
首先回忆一下插入排序，是从前开始往后找，判断每个数和前面已经排好的数大小，将这个数插入到正确的位置。

```js
1243 => // 逆序对1（4，3）
12453 => // 逆序对（4，3），（5，3）
12543 => // 逆序对（5，4），（4，3），（5，3）  
```

可以发现，插入排序每一次元素的向后移位就是对应着一个逆序对

如果是归并排序呢？归并排序主要的点先将数组拆成足够小的子数组（里面只有一个元素，这样这个子数组就是有序的了），然后合并有序的数组。

每次合并有序数组的时候，会创建一个新的数组，向里面放入有序的数。在把后面的数组的某个元素放入新数组的时候，就可以发现有前面数组剩下的数那么多个逆序对。

```js
[1,2,5, 6, 7][3,4]

[1,2] => [1,2,3] => // 逆序对(5,3)，（6，3），（7，3）
[1,2,3] => [1,2,3,4] => // 逆序对（5，4），（6，4），（7，4）
[1,2,3,4] => [1,2,3,4,5,6,7] => // 逆序对无
```

归并排序一定要递归写吗？不是。也可以采用非递归的方式，在数组里面原地拆成子数组。

*回溯算法*就是一个类似枚举的过程，在操作的过程，将每一种方法都会去尝试，遇到不满足条件的情况就退回来采用下一种方式。

*0-1背包问题*：我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？

*动态规划*和*回溯算法*都能解决0-1背包问题，但是*动态规划*表现更好。*回溯算法*中存在则重复计算子问题的问题，可以采用备忘录的方式，将已经计算过的记录下来，从而避免重复计算子问题。

使用动态规划解决背包问题

我们用一个数组`state`来存储物品依次被放入背包或者不放入背包时，背包的状态。

```js
let w = 11
let weight = [2, 3, 4, 6, 2]

state = []

// 第一个物品放入背包, 或者不放入背包, 重量为0和2
state = [0, undefined, 2]
// 第二个物品放入背包
state = [0, undefined, 2, 0 + 3, undefined, 2 + 3]
// 第三个放入背包
state = [0 + 0 + 0, undefined, 2 + 0 + 0, 0 + 3 + 0, 0 + 0 + 4, 2 + 3 + 0, 2 + 0 + 4, 0 + 3 + 4, undefined, 2 + 3 + 4 ]
// 依次类推

// 如何写代码，判断结束条件？

// 初始状态，第一个物品被放入或者不放入的状态
state[0] = true
state[weight[0]] = true
// 然后依次放入后面的几个
for (let i = 1; i < weight.length; i++) {
  let next = weight[i]
  // 如何奖下一个元素的重量状态叠加到state之前的状态中去呢？
  // state长度最大值就是期望值11，所以任何小于11的数组中为true的，就是前面的叠加重量的状态
  // 为undefined就是没有叠加到的
  for (let j = w - 1; j >= 0; j--) {
    if (state[j]) { // 只要前面有叠加的，这再次叠加。
      state[j + next] = true
    }
  }
}
// 从state[w - 1]开始向前取，第一个不为undefined则是最大的重量

for (let k = w - 1; k  >= 0; k--) {
  if (state[k] === true) {
    return k
  }
}

```

动态规划理论：*最优子结构*、*无后效性*、*重复子问题*


