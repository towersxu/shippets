# 2019年11月12日

浏览器检测css属性

```js
result = CSS.supports('filter', 'blur(5px)'); // true

// 当浏览器不支持某个CSS属性的时候，就算你强制设置，获取的计算值也不会是你设置的属性值
document.head.style.filter = 'blur(5px)';
result = window.getComputedStyle(document.head).filter == 'blur(5px)';

```

CSS Object Model

*分治算法*一般是通过递归来实现的，在每一层递归中，都会涉及到将原问题分解为一些列子问题，如果子问题足够小，则直接求值。最后将子问题的结果合并。

*分治算法的条件*是原问题分解成的子问题具有相同模式，子问题能独立求解，相互之间也没有相关性。

如何计算出一组数中逆序对的个数？

在理想的排序过程，每次两个数交换就是一个逆序对。在我们常见的排序中，快速排序、插入排序、归并排序他们是否有额外的交换呢？
首先回忆一下插入排序，是从前开始往后找，判断每个数和前面已经排好的数大小，将这个数插入到正确的位置。

```js
1243 => // 逆序对1（4，3）
12453 => // 逆序对（4，3），（5，3）
12543 => // 逆序对（5，4），（4，3），（5，3）  
```

可以发现，插入排序每一次元素的向后移位就是对应着一个逆序对

如果是归并排序呢？归并排序主要的点先将数组拆成足够小的子数组（里面只有一个元素，这样这个子数组就是有序的了），然后合并有序的数组。

每次合并有序数组的时候，会创建一个新的数组，向里面放入有序的数。在把后面的数组的某个元素放入新数组的时候，就可以发现有前面数组剩下的数那么多个逆序对。

```js
[1,2,5, 6, 7][3,4]

[1,2] => [1,2,3] => // 逆序对(5,3)，（6，3），（7，3）
[1,2,3] => [1,2,3,4] => // 逆序对（5，4），（6，4），（7，4）
[1,2,3,4] => [1,2,3,4,5,6,7] => // 逆序对无
```

归并排序一定要递归写吗？不是。也可以采用非递归的方式，在数组里面原地拆成子数组。

*回溯算法*就是一个类似枚举的过程，在操作的过程，将每一种方法都会去尝试，遇到不满足条件的情况就退回来采用下一种方式。

*0-1背包问题*：我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大？

*动态规划*和*回溯算法*都能解决0-1背包问题，但是*动态规划*表现更好。*回溯算法*中存在则重复计算子问题的问题，可以采用备忘录的方式，将已经计算过的记录下来，从而避免重复计算子问题。

使用动态规划解决背包问题

我们用一个数组`state`来存储物品依次被放入背包或者不放入背包时，背包的状态。

```js
let w = 11
let weight = [2, 3, 4, 6, 2]

state = []

// 第一个物品放入背包, 或者不放入背包, 重量为0和2
state = [0, undefined, 2]
// 第二个物品放入背包
state = [0, undefined, 2, 0 + 3, undefined, 2 + 3]
// 第三个放入背包
state = [0 + 0 + 0, undefined, 2 + 0 + 0, 0 + 3 + 0, 0 + 0 + 4, 2 + 3 + 0, 2 + 0 + 4, 0 + 3 + 4, undefined, 2 + 3 + 4 ]
// 依次类推

// 如何写代码，判断结束条件？

// 初始状态，第一个物品被放入或者不放入的状态
state[0] = true
state[weight[0]] = true
// 然后依次放入后面的几个
for (let i = 1; i < weight.length; i++) {
  let next = weight[i]
  // 如何奖下一个元素的重量状态叠加到state之前的状态中去呢？
  // state长度最大值就是期望值11，所以任何小于11的数组中为true的，就是前面的叠加重量的状态
  // 为undefined就是没有叠加到的
  for (let j = w - 1; j >= 0; j--) {
    if (state[j]) { // 只要前面有叠加的，这再次叠加。
      state[j + next] = true
    }
  }
}
// 从state[w - 1]开始向前取，第一个不为undefined则是最大的重量

for (let k = w - 1; k  >= 0; k--) {
  if (state[k] === true) {
    return k
  }
}

```

动态规划理论：*最优子结构*、*无后效性*、*重复子问题*

*http3*是以前的*http over QUIK*, QUIK是

- 在 HTTP/1.0 中，客户端和服务器之间交换的每个请求/响应都会创建一个新的 TCP 连接，这意味着所有 TCP/TLS 握手均在每个请求之前完成，因此所有请求都会产生延迟。而且TCP 不是在建立连接后尽快发送所有未完成的数据，而需要“慢启动”的预热时间，这使 TCP 拥塞控制算法能够随时确定可以传输的数据量，防止网络路径发生拥塞，并避免将无法处理的数据包都堆到网络中。但是，由于新连接必须经过缓慢的启动过程，因此它们无法立即使用所有可用的网络带宽。
- HTTP/1.1引入了`keep alive`的概念来解决1.0的问题，`keep alive`允许客户端复用TCP连接，从而分摊了建立初始连接和针对多个请求缓慢启动的成本。尽管多个请求可以共享同一个连接，但它们仍需逐个序列化它们，因此任意时点上客户端和服务器只能为每个连接执行一次请求/响应交换。因此在网络层上获得并发能力的唯一方法是并行使用多个 TCP 连接到同一来源，代价就是牺牲了活动连接的大多数好处。
- HTTP2.0引入了 HTTP stream的概念，这是一种抽象概念，允许 HTTP 实现将不同的 HTTP 交换并发地复用到同一 TCP 连接上， 使浏览器更高效地复用 TCP 连接。这个解决了最初的问题——单个 TCP 连接的使用效率低——因为现在可以通过同一连接同时传输多个请求/响应。但是，即使只有单个请求丢失数据，所有请求和响应也会同样受到数据包丢失（比如因为网络拥塞）的影响。

*行首阻塞(head-of-line blocking)*:TCP 的作用是以正确的顺序从一个端点到另一端点传递整个字节流。当承载某些字节的 TCP 数据包在网络路径上丢失时将在流中造成间隙，并且 TCP 需要在检测到丢失时重新发送受影响的数据包来弥补这一间隙。这样做时，即使丢失数据之后的数据属于完全不同的 HTTP 请求，自己也根本没有丢失，也能正常传递成功，它们还是不能正常传递给应用程序。因此它们只能毫无必要地产生延迟，因为 TCP 无法知道应用程序缺少了丢失的数据包时能否处理后面的数据。这个问题称为“行首阻塞”。

- http3.0: 它不是使用 TCP 作为会话的传输层，而是使用 QUIC （一种新的互联网传输协议）。该协议率先在传输层将流作为一等公民引入。多个 QUIC 流共享相同的 QUIC 连接，因此不需要额外的握手和慢启动来创建新的 QUIC 流。但 QUIC 流是独立交付的，因此在大多数情况下，只影响一个流的丢包不会影响其他流。这是因为 QUIC 数据包封装在 UDP 数据报的顶部。

与 TCP 相比，使用 UDP 可以提供更大的灵活性，并且可以使 QUIC 实现完全存在于用户空间中——协议实现的更新不像 TCP 那样依赖操作系统的更新。借助 QUIC，可以将 HTTP 级别的流简单地映射到 QUIC 流的顶部，从而在享受 HTTP/2 所有好处的同时避免了行首阻塞。

QUIC 还结合了典型的 3 向 TCP 握手和 TLS 1.3 的握手。结合这些步骤意味着加密和身份验证能够默认提供，并且还可以更快地建立连接。换句话说，即使 HTTP 会话中的初始请求需要新的 QUIC 连接，在数据开始流动之前的等候延迟也比使用 TLS 的 TCP 要低。
![quic](https://github.com/towersxu/snippets/raw/master/img/QUIC.png)

QUIC 带来的一项重要功能是在不同的网络（例如你早上上班时在家中的 WiFi 网络和运营商移动网络）之间进行无缝、透明的连接迁移，而无需创建全新的连接。
