# 2019年11月19日

Integer. valueOf()可以将基本类型int转换为包装类型Integer，或者将String转换成Integer，String如果为Null或“”都会报错

在 Java 8 中，Integer 缓存池的大小默认为 -128~127，在启动JVM的时候，可以设置AutoBoxCacheMax来指定缓冲池大小。

String 被声明为 final，因此它不可被继承。(Integer 等包装类也不能被继承）

String不可变的好处是：

1. 可以缓存*hash*值，因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。
2. String有一个String Pool,使其不可变，便于重复使用。
3. 不可变性具备线程安全，可以在多线程中安全使用。

`StringBuffer`和`StringBuilder`是可变的。但是`StringBuffer`是线程安全的，因为`StringBuffer`内部使用了`synchronized`进行同步。

`synchronized`是实现线程同步的基本手段，然而底层实现还是通过锁机制来保证，对于被synchronized修饰的区域每次只有一个线程可以访问，从而满足线程安全的目的。

当一个类被`final`修饰了后，这个类不能被继承。

当一个方法被`final`修饰了后，这个方法不能被重写。

重写就是子类修改父类的方法，该方法的入参，返回值，抛出异常都不能改变。（抛出的异常可以更小一些）
之类如果还想调用父类的方法，则需要用`super`

重载是一个类里面，有多个同名的方法，这些方法的入参不一样。

多态是建立在重写的基础之上的，是类与类之间的关系，是发生在不同的类之间的，子类重写父类的方法。实现不同的子类，不同的实现形态。
多态有3个条件

1. 继承
2. 重写(重写父类继承的方法)
3. 父类引用指向子类对象

而重载是类的内部的方法构型上的不同，是发生在同一个类里面的。同一个函数名称，参数不同的多个方法，实现同一类型的功能。

多态是基于对抽象方法的覆盖来实现的，用统一的对外接口来完成不同的功能。重载也是用统一的对外接口
来完成不同的功能。那么两者有什么区别呢？

重载，是指允许存在多个同名方法，而这些方法的参数不同。重载的实现是：编译器根据方法不同的参数表
，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期
就绑定了。

多态：是指子类重新定义父类的虚方法（virtual,abstract）。当子类重新定义了父类的虚方法后，父类根据
赋给它的不同的子类，动态调用属于子类的该方法，这样的方法调用在编译期间是无法确定的。
不难看出，两者的区别在于编译器何时去寻找所要调用的具体方法，对于重载而言，在方法调用之前，编译
器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于多态，只有等到方法调用的那一刻
，编译器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。

`float`是单精度类型,精度是8位有效数字，取值范围是10的-38次方到10的38次方，float占用4个字节的存储空间
double是双精度类型，精度是17位有效数字，取值范围是10的-308次方到10的308次方，double占用8个字节的存储空间
当你不声明的时候，默认小数都用double来表示，所以如果要用float的话，则应该在其后加上f

例如：float a=1.3;

则会提示不能将double转化成float  这成为窄型转化
如果要用float来修饰的话，则应该使用float a=1.3f
注意float是8位有效数字，第7位数字将会产生四舍五入
所以如果一个float变量 这样定义:  float a=1.32344435;   则第7位将产生四舍五入(5及5以下的都将舍去)

```java
double d = 1.1f // 正确
float f = 1.1 // 错误
```

从 Java 7 开始，可以在 switch 条件判断语句中使用 String 对象。

switch 不支持 long，是因为 switch 的设计初衷是对那些只有少数的几个值进行等值判断，如果值过于复杂，那么还是用 if 比较合适。

*里氏替换原则*主张使用“抽象”和“多态”将设计中的静态结构改动为动态结构，维持设计的封闭性。“继承必须确保超类所拥有的性质在子类中仍然成立。”也就是说当一个之类的实例应该能够替换任何其超类的实例时，他们之间才有is-A的关系

Java抽象类和普通类最大的区别是抽象类不能被实例化，必须要继承抽象类才能实例化其子类。如果一个类包含了抽象方法，那么这个类必须声明为抽象类。

使用接口：

- 需要让不相关的类都实现一个方法，例如不相关的类都可以实现 Compareable 接口中的 compareTo() 方法；
- 需要使用多重继承。

使用抽象类：

- 需要在几个相关的类中共享代码。
- 需要能控制继承来的成员的访问权限，而不是都为 public。
- 需要继承非静态和非常量字段。

在很多情况下，接口优先于抽象类。因为接口没有抽象类严格的类层次结构要求，可以灵活地为一个类添加行为。并且从 Java 8 开始，接口也可以有默认的方法实现，使得修改接口的成本也变的很低。

接口默认的方法实现是接口里面方法采用default修饰符，使得方法可以在接口里面就定好实现。这样所有实现了这个接口的类都会有这个方法。


