# 算法基础

## 什么是复杂度分析，如何进行复杂度分析

复杂度描述的是算法执行时间（或占用空间）与数据规模的增长关系。

算法的执行时间与每行代码的执行次数成正比，用T(n) = O(f(n))表示，其中T(n)表示算法执行总时间，f(n)表示每行代码执行总次数，而n往往表示数据的规模。

复杂度分析法则

1. 单段代码看高频：比如循环。
2. 多段代码取最大：比如一段代码中有单循环和多重循环，那么取多重循环的复杂度。
3. 嵌套代码求乘积：比如递归、多重循环等
4. 多个规模求加法：比如方法有两个参数控制两个循环的次数，那么这时就取二者复杂度相加。

常用的复杂度级别？

多项式阶：随着数据规模的增长，算法的执行时间和空间占用，按照多项式的比例增长。包括，
O(1)（常数阶）、O(logn)（对数阶）、O(n)（线性阶）、O(nlogn)（线性对数阶）、O(n^2)（平方阶）、O(n^3)（立方阶）

非多项式阶：随着数据规模的增长，算法的执行时间和空间占用暴增，这类算法性能极差。包括，
O(2^n)（指数阶）、O(n!)（阶乘阶）

## 数组动态扩容的算法复杂度是多少

```java

// 全局变量，大小为10的数组array，长度len，下标i。
int array[] = new int[10]; 
int len = 10;
int i = 0;

// 往数组中添加一个元素
void add(int element) {
   if (i >= len) { // 数组空间不够了
     // 重新申请一个2倍大小的数组空间
     int new_array[] = new int[len*2];
     // 把原来array数组中的数据依次copy到new_array
     for (int j = 0; j < len; ++j) {
       new_array[j] = array[j];
     }
     // new_array复制给array，array现在大小就是2倍len了
     array = new_array;
     len = 2 * len;
   }
   // 将element放到下标为i的位置，下标i加一
   array[i] = element;
   ++i;
}
```

最好是O(1)，最差是O(n), 均摊是O(1), 均摊复杂度计算方法为前n个操作复杂度都是O(1)，第n+1次操作的复杂度是O(n)，所以把最后一次的复杂度分摊到前n次上，那么均摊下来每次操作的复杂度为O(1)。

- 1）代码在绝大多数情况下是低级别复杂度，只有极少数情况是高级别复杂度；
- 2）低级别和高级别复杂度出现具有时序规律。

均摊结果一般都等于低级别复杂度。

## 缓存淘汰策略

先进先出策略FIFO、最少使用策略LFU、最近最少使用策略LRU

## 什么是队列，有哪些方式实现，有什么呢优缺点

队列可以根据不同的实现，分为`顺序队列`和`链式队列`

顺序队列的问题，因为使用了数组存储，每次出列都会涉及到搬移，效率不高。可以考虑在队列满了的时候再一次搬移。

`循环队列`：为了解上面t=n的搬移问题，我们可以构建一个环作为队列。

## 使用递归有哪些常见的问题，如果解决

堆栈溢出和重复计算是两个常见的问题

解决重复计算可以采用散列表来保存已经求解过的f(k),及在递归调用的时候判断f(k)是否已经计算过了，如果计算过了，则不再重复计算。

## 快速排序和归并排序

他们的时间复杂度是`nlogn`, 都使用递归的思路来实现。递归的方法也类似，都是如下这种格式

```js
function sort(arr) {}

function sortQuick (arr, start, end) {
  if (start >= end) return
  let q = position(arr, start, end)
  sortRecursion(arr, start, q-1)
  sortRecursion(arr, q+1, end)
}

function sortMerge (arr, start, end) {
  if (start >= end) return
  let q = (start + end) >> 1
  sortMerget(arr, start, q)
  sortMerget(arr, q+1, end)
  merge(arr, start, q, end)
}

```

从上面的代码可以看到，快速排序的具体的排序方法在前面，归并排序的在后面。

- 快速排序的排序逻辑是选取需要排序的区域最后一位作为基准点，比它大的放右边，小的放左边。然后返回当前基准点排序后的位置。然后把这个位置作为继续排序的边界。直到边界缩小到单个数字。
- 归并排序则相反，归并排序是先递归，也就是先处理相邻的两个元素的顺序，然后再处理更大边界的元素的顺序。由于先处理了小边界的元素顺序。所以能保证处理大边界元素顺序的时候，保证左右两边的数组是有序的。所以这时归并排序的排序逻辑就变成了合并两个有序数组。

## 插入排序和选择排序

插入排序和选择排序时间复杂度都是n^2，实现的方法不同点可以根据名字来判断。他们都是从前往后排序，前面是有序的，后面是无序的。

- 插入排序：把无序部分第一个元素，插入到有序部分对应的位置。具体的写法是，从第一位开始遍历，每一位从后向前开启与他前面的元素进行位置交换，直到交换到正确的位置。
- 选择排序：把无序部分中选取最小的原生放入有序部分的最后一位。

## 桶排序、基数排序

对全国所有50万高考学生成绩进行排序，可以使用桶排序，分为0-700个桶，然后根据每个桶的总数来计算即可。

把所有的身份证号按照顺序排序，可以把身份证分为18个单独的”位“来进行比较，每个账号比较18次，所以复杂度仍然是N。

基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且位之间有递进的关系，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则，基数排序的时间复杂度就无法做到 O(n) 了。
